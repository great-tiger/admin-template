1、webpack-dev-server --open --env dev 
--env 向 webpack.config.js 传递参数 具体查看 webpack help
2、内敛样式要这么写：style={{width:20+'%'}}
3、npm start 启动开发环境
   入口文件为 ./src/client.js  虽然Base.js中配置的index.js，但是在Dev.js和Dist.js中都重写了。
   输出文件为 app.js
   publicPath: './assets/' 开发时，可以从这个目录获取文件。实质上webpack-dev-server 会把文件缓存在内存中，并未存入到该路径中。
   所以在index.html中，我们可以看到这句话。
   <script type="text/javascript" src="/assets/app.js"></script>
4、npm run build 生成部署文件
   生成部署文件一共有三个步骤，分别是：
   npm run clean 清空dist目录
   npm run copy  拷贝index.html和assets文件夹
   webpack --progress --bail --env dist -p  使用webpack生成输出文件
   --progress  显示进度
   --bail      Abort the compilation on first error
   -p          执行优化
   --env dist  向配置文件传参
5、resolve 字段，如何获取模块有关
     resolve: {
        alias: {
          actions: `${this.srcPathAbsolute}/actions/`,
          components: `${this.srcPathAbsolute}/components/`,
          config: `${this.srcPathAbsolute}/config/${this.env}.js`,
          images: `${this.srcPathAbsolute}/images/`,
          sources: `${this.srcPathAbsolute}/sources/`,
          stores: `${this.srcPathAbsolute}/stores/`,
          styles: `${this.srcPathAbsolute}/styles/`
        },
        extensions: ['.js', '.jsx'], 
        modules: [
          this.srcPathAbsolute,
          'node_modules'
        ]
      }
   extensions 自动补全的扩展名
   modules 猜测 查找模块的路径
   alias 别名 猜测 import XXX from "actions" 会把action替换成配置中的值
6、
   {
      test: /\.(woff|woff2|ttf|eot|svg)(\?v=[0-9]\.[0-9]\.[0-9])?$/,
      loader: 'url-loader?limit=10000&name=fonts/[hash:8].[name].[ext]'
   }
  该generator加入bootstrap后报错，改换loader后可以了，默认用的fileloader。
  limit 表示小于该值则输出内敛。
  name  指定输出文件名。name=fonts/[hash:8].[name].[ext] 表示输出到fonts文件夹下。
7、注意，在图片标签中直接使用src路径，并不会触发loader。图片并不会被webpack大包。需要写成
  import user  from '../images/admin-img/user2-160x160.jpg';
  <img src={user} className="img-circle" alt="User Image" />
  如果就是想直接使用img地址，则可以把图片放到static中，因为该文件夹中的东西，会被直接拷贝到dist目录中。

  但是css中直接引用的img font都被打包了。

8、默认生成的项目加入bootstrap后,字体引入报错。原配置中用的是file-loader,改成url-loader后解决了问题。
  {
    test: /\.(woff|woff2|ttf|eot|svg)(\?v=[0-9]\.[0-9]\.[0-9])?$/,
    loader: 'url-loader?limit=10000&name=fonts/[hash:8].[name].[ext]'
  }
  翻看源码发现url-loader使用了file-loader
9、react-router-redux 不是必须的，使用它可以向store中保存一些状态信息，比如URL。解决的是:react-router与redux之间的问题。
没有react-router-redux，react react-redux redux react-router 之间也可以很好的工作。
什么时候需要使用它呢，调试的时候，可能会需要它。

也就是说，下面的代码中，store会被正常的传入到App,Home等组件中。在App等组件中，正常使用connect就可以了。
<Provider store={store}>
    <div>
      <Router history={history}>
        <Route path="/" component={App}>
          <IndexRoute component={Home}/>
          <Route path="foo" component={Foo}/>
          <Route path="bar" component={Bar}/>
        </Route>
      </Router>
      <DevTools />
    </div>
  </Provider>
10、`You cannot change <Router routes>; it will be ignored` when hot-loading
解决这个问题的办法就是它router提出来，这样每次hot-loading的时候，就没有warning了。

if (module.hot) {
  console.log("module.hot",module.hot);
  module.hot.accept('./components/App', () => {
    const NextApp = require('./components/App').default; // eslint-disable-line global-require
    ReactDOM.render(
      <AppContainer>
         <Provider store={store}>
           <Router history={hashHistory}>
               {routes()}
          </Router>
        </Provider>
      </AppContainer>,
      document.getElementById('app')
    );
  });
}
11、